function savePrefs(name,data) -- saves data to a file
	local file=io.open(name,"w")
	file:write(serialize(data))
	file:close()
end

function readPrefs(name) -- reads data from a file
	local file=fs.open(name,"r")
	if not file then return false end
	local dat=unserialize(file.readAll())
	file.close()
	return dat
end

-- base converter
-- usage:
-- bcv(number,charlist,returnTable?)
function bcv(N,C,TF)
	if not C then
		return string.format("%X",N) -- default to hex
	end
	local Str=""
	local Tbl={}
    repeat
        local D=(N%(#C))+1
        N=math.floor(N/(#C))
		Str=string.sub(C,D,D)..Str
		table.insert(Tbl,1,D)
    until N==0
	if TF then
		return Tbl
	end
	return Str
end

function serializeImpl(t) -- converts anything into a string
	local sType = type(t)
	if sType == "table" then
		local lstcnt=0
		for k,v in pairs(t) do
			lstcnt = lstcnt + 1
		end
		local result = "{"
		local aset=1
		local comma=false
		for k,v in pairs(t) do
			comma=true
			if k==aset then
				result = result..serializeImpl(v)..","
				aset=aset+1
			else
				result = result..("["..serializeImpl(k).."]="..serializeImpl(v)..",")
			end
		end
		if comma then
			result=string.sub(result,1,-2)
		end
		result = result.."}"
		return result
	elseif sType == "string" then
		return string.format("%q",t) -- improved from textutils
	elseif sType == "number" or sType == "boolean" or sType == "nil" then
		return tostring(t)
	elseif sType == "function" then -- function i added
		local status,data=pcall(string.dump,t) -- convert the function into a string
		if status then
			return 'func('..string.format("%q",data)..')' -- format it so it dosent screw up syntax
		else
			error()
		end
	else
		error()
	end
end
 
function split(T,func) -- splits a table
	if func then
		T=func(T) -- advanced function
	end
	local Out={}
	if type(T)=="table" then
		for k,v in pairs(T) do
			Out[split(k)]=split(v) -- set the values for the new table
		end
	else
		Out=T
	end
	return Out
end
 
function serialize( t ) -- TODO: combine with serializeImpl
	t=split(t)
	return serializeImpl( t, tTracking )
end
 
function unserialize( s ) -- converts a string back into its original form
	if type(s)~="string" then
		error("String exepcted. got "..type(s),2)
	end
	local func, e = loadstring( "return "..s, "serialize" )
	local funcs={} -- a table to store all the functions generated by f() (for securety)
	if not func then
		return e
	end
	setfenv( func, { -- make sure nothing can be called within the function
		func=function(S) -- puts function requests into the funcs table
			local new={}
			funcs[new]=S 
			return new
		end,
	})
	return split(func(),function(val) -- apply functions if any
		if funcs[val] then
			return loadstring(funcs[val])
		else
			return val
		end
	end)
end

function zfill(N) -- ensures a hax number has 2 digits
	N=bcv(N)
	Zs=""
	if #N==1 then
		Zs="0"
	end
	return Zs..N
end

function sure(N,n) -- make sure there is no errors when decoding a hex stream
	if (l2-n)<1 then N="0" end
	return N
end

function hexToStr(S) -- converts a hex stream back into a character
	Out=""
	for l1=1,#S,2 do
		l2=(#S-l1)+1
		CNum=tonumber("0x"..sure(string.sub(S,l2-1,l2-1),1) .. sure(string.sub(S,l2,l2),0))
		Out=string.char(CNum)..Out
	end
	return Out
end

function strToHex(S) -- converts a string into a hex stream (most usefull when you dont want a string to screw up formatting)
	local O=""
	for char in string.gmatch(S,".") do
		O=O..zfill(string.byte(char))
	end
	return O
end

function compress( ... ) -- serializes all of its arguments into a table and catches errors
	local tArgs={ ... }
	local E,D=pcall(infutil.serialize,tArgs) 
	if E then
		return D
	else
		return false
	end
end

function decompress(S) -- convert a serialized table into a normal one and catches errors
	local E,D,C=pcall(unserialize,S)
	if C or not E then
		return false
	else
		return D
	end
end

function rev(T) -- reverses a tables indexes
	local oT={}
	for k,v in pairs(T) do
		oT[(#T-k)+1]=v
	end
	return oT
end

function receive(ID,nTimeout) -- receive a message from a specific id
	local timer = nil
	if nTimeout then
		timer = os.startTimer( nTimeout )
	end
	while true do
		local e, p1, p2, p3 = os.pullEvent()
		if e == "rednet_message" and p1 == ID then
			return p2
		elseif e == "timer" and p1 == timer then
			return
		end
	end
end

function clear() -- so you dont have to do it yourself
	term.clear()
	term.setCursorPos(1,1)
end
