local func={
	receive=function(self,timeout,sID)
		local timer={}
		if timeout then
			timer=os.startTimer(timeout) -- start timer
		end
		while true do
			local tpe,id,data,dist=os.pullEvent() -- grab event
			local rData=infutil.decompress(data) or {} -- decompresses rednet message
			if id==timer then
				return -- return if time limit was reached
			elseif rData and id==self.host then -- check if you received a message
				if rData[1]=="netclient" then -- make sure it is directed twards this api
					if rData[2]=="reqcon" and rData[4]==self.id then
						rednet.send(self.host,infutil.compress("nethost",self.host,"gotcon",self.id,rData[3],rData[3])) -- pong if connection was succesful
					elseif rData[2]=="message" and (sID==nil or sID==rData[3]) and rData[6]==self.id then -- check if it received a net messsage
						rData[5]=rData[5]+dist -- add distance
						return rData[3],rData[4],rData[5]
					end
				end
			end
		end
	end,
	connect=function(self,id)
		rednet.send(self.host,infutil.compress("nethost",self.host,"connect",id)) -- request a connection to an id
		local timer = os.startTimer(1) -- TODO: configurable timeout
		local data,data2
		while true do
			local e, p1, p2, p3 = os.pullEvent()
			data2=infutil.decompress(p2) or {} -- decompress message
			if e == "rednet_message" and p1 == self.host and data2[1]=="gotcon" and data2[2]==id then -- check if the id ponged
				data=p2
				break
			elseif e == "timer" and p1 == timer then
				return false -- return when time limit was reached
			end
		end
		table.remove(data2[3])
		table.insert(data2[3],1,data2[2])
		self.cns[id]=infutil.rev(data2[3]) -- reverse the path and set it as a new connection (so you dont have to keep connecting)
		return true
	end,
	send=function(self,id,data,fdist)
		fdist=fdist or 0 -- allow distance spoofing >_>
		if not self.cns[id] then -- check if it knows the path for the id
			if not self:connect(id) then
				return false -- recipient wasnt receiving
			end
		end
		rednet.send(self.host,infutil.compress("nethost",self.host,"send",self.cns[id],data,self.id,fdist)) -- send the message
		-- TODO: return false if the recipient wasnt receiving and had a path
		return true
	end,
	addlink=function(self,pass) -- request to be added as a host
		rednet.send(self.host,infutil.compress("nethost",self.host,"addlink",pass,os.getComputerID()))
	end,
	remlink=function(self,pass) -- request to be removed as a host000
		rednet.send(self.host,infutil.compress("nethost",self.host,"remlink",pass,os.getComputerID()))
		-- TODO: check if link functions have suceeded
	end,
	convpull=function(self,tpe,id,data,dist) -- convert a netapi event into rednet_message format
		local rData=infutil.decompress(data) or {}
		if rData[1]=="netclient" then
			if rData[2]=="reqcon" and rData[4]==self.id then
				rednet.send(self.host,infutil.compress("nethost",self.host,"gotcon",self.id,rData[3],rData[3]))
			elseif rData[2]=="message" and (sID==nil or sID==rData[3]) and rData[6]==self.id then
				rData[5]=rData[5]+dist
				return rData[3],rData[4],rData[5]
			end
		end
		return nil
	end
}
-- returns a list of all hosts in a table
-- sorted by distance in decending order
-- there is no authentication yet so someone can fake themselves as a host and steal data :s

function hostsInRange(TF)
	snet.open()
	local hosts={}
	local hosts2={}
	rednet.broadcast(infutil.compress("nethost","ping")) -- look for hosts
	local sDist=-1
	local timer=os.startTimer(0.1) -- timeout (will probably fail on servers with high load)
	while true do
		local tpe,id,data,dist=os.pullEvent()
		if id==timer then
			break -- break if the time limit was reached
		elseif data==infutil.compress("netclient","pong") and (dist<sDist or sDist==-1) then -- check if a server responded
			hosts[id]=dist
			table.insert(hosts2,{dist,id})
		end
	end
	if TF then
		table.sort(hosts2,function(a,b) return a[1]<b[1] end) -- sort it using a custom function
		local out={}
		for k,v in pairs(hosts2) do -- loop though all the tables
			out[k]=v[2]
		end
		return out
	end
	return hosts
end

function new(host) -- creates a new linking table (functions defined in table "func")
	snet.open()
	local sDist=-1
	if not host then
		rednet.broadcast(infutil.compress("nethost","ping"))
		local timer=os.startTimer(0.1)
		while true do
			local tpe,id,data,dist=os.pullEvent()
			if id==timer then
				break
			elseif data==infutil.compress("netclient","pong") and (dist<sDist or sDist==-1) then -- check if a server responded and the distance is less than the minimum found
				host=id
				sDist=dist
			end
		end
	end
	local Out=infutil.split(func) -- apply function to the new table
	Out.host=host -- give it a host
	Out.dist=0 -- unimplemented
	Out.cns={} -- path table
	Out.id=os.getComputerID() -- own id, only valid when the client is authenticated via addlink
	return Out
end